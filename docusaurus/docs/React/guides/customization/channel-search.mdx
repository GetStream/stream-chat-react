---
id: channel_search
title: Channel Search
---

Channel search is used to look up channels based on query that includes user
input. Depending on your case, it can be used to either find existing
conversations, initiate new ones, or do both.

There are two ways to use the built-in search functionality:

1. by enabling search in the `ChannelList` component with the
   `showChannelSearch` prop,
2. or by using the `ChannelSearch` component directly.

No matter which way works better for you, the `ChannelSearch` component will be
managing the UI logic.

In the first case, when you're using the search functionality of the
`ChannelList` component, the `ChannelSearch` is rendered by the `ChannelList`.
You can still pass props to the underlying `ChannelSearch` via the
`additionalChannelSearchProps`.

For example, this is how you enable search in the `ChannelList` (with the
`showChannelSearch` prop), and configure search results to include both channels
and users by passing settings in the `additionalChannelSearchProps`:

```jsx
<ChannelList
  filters={filters}
  sort={sort}
  options={options}
  showChannelSearch
  additionalChannelSearchProps={{ searchForChannels: true }}
/>
```

In the second case, when you're using the `ChannelSearch` component directly,
you can pass settings right as the props of the `ChannelSearch` component:

```jsx
<ChannelSearch searchForChannels />
```

## ChannelSearch Component Anatomy

`ChannelSearch` component consists of the search bar (including the search
input), results header, and the results list (consisting of individual search
results items).

Each of this components can be overriden by passing custom components in the
`ChannelSearch` props:

```jsx
<ChannelSearch
  SearchBar={CustomSearchBar}
  SearchInput={CustomInput}
  SearchResultsHeader={CustomHeader}
  SearchResultsList={CustomList}
  SearchResultItem={CustomItem}
/>
```

If you're using the search functionality of the `ChannelList` components, you
can pass the same custom components to the `additionalChannelSearchProps`:

```jsx
<ChannelList
  filters={filters}
  sort={sort}
  options={options}
  showChannelSearch
  additionalChannelSearchProps={{
    SearchBar: CustomSearchBar,
    SearchInput: CustomInput,
    SearchResultsHeader: CustomHeader,
    SearchResultsList: CustomList,
    SearchResultItem: CustomItem,
  }}
/>
```

Next, we'll go through some of these customization options in depth. But first
we recommend that you check out the [many customization options]() available out
of the box that do not require providing custom components.

<!-- Note: I'm removing this whole section because changing the order of search
results in the `SearchResultList` component breaks keyboard navigation in the
list. At the same time, I can't think of any useful examples that DON'T change
the order of the results, so it's better to just omit the whole thing.

## Overriding the Search Result List

When overriding the search result list, you get direct access to an array
containing search results. This makes it an ideal place to add client-side
sorting or grouping. For example, you might want to group channels and users
separately, then you can do this:

```jsx
function CustomSearchResultsList({ results, SearchResultItem, ...itemProps }) {
  const channels = results.filter((item) => item.cid);
  const users = results.filter((item) => !item.cid);
  let itemIndex = 0;

  return [channels, users]
    .filter((group) => group.length > 0)
    .map((group, groupIndex) => (
      <div key={groupIndex} className="search-results-group">
        {group.map((item) => {
          const children = (
            <div key={item.id} className="search-results-item">
              <SearchResultItem
                result={item}
                index={itemIndex}
                {...itemProps}
              />
            </div>
          );
          itemIndex++;
          return children;
        })}
      </div>
    ));
}
```

```css

```

Note that we're not reimplementing previews for search result items, and just
rending `SearchResultItem` instead. Since the `SearchResultItem` component is
also overridable, it's best to always you the component provided in props.

Keeping track of item indicies as important, since the SDK provides index-based
support for keyboard navigation in search results. So make sure that the
consequitive index prop is set on each `SearchResultItem`.

When overriding `SearchResultsList`, we don't have to worry about loading or
empty states (the component is not rendered at all in those cases). Custom
loader can be added by passing a custom component in the `SearchLoading` prop.
Custom empty state placeholder can be passed in the `SearchEmpty` prop. -->

## Overriding the Search Result Item

You can override the way each search result item is presented by providing a
custom `SearchResultItem`.

```jsx
<ChannelSearch SearchResultItem={CustomSearchResultItem} />
```

```jsx
<ChannelList additionalChannelSearchProps={{ SearchResultItem: SearchResultItem }} />
// Don't forget to provide filter and sort options as well!
```

This component receives a search result item as a prop, which can be either a
`UserResponse` or a `Channel` (if `searchForChannels` option is enabled).

Our implementation should be able to:

1. Display both channel and user search result items.
2. Provide visual feedback for an item focused with arrow keys. We can do it by
   looking at the `focusUser` prop which contains the index of the currently
   selected item.
3. When clicked, it should invoke the `selectResult` callback.

```jsx

```

```css

```

## Implementing Search from Scratch

You don't have to rely on the components provided by the SDK to implement
search. For ultimate customizability it's not too difficult to implement search
from scratch. You'll have to manage state yourself, and use our low-level client
methods to query for results, but the upside is that you can manipulate the
results however you like.

Refer to our client documentation to learn how to query for [channels](),
[users](), or [messages](). As a quick reference, here are the queries we will
be making:

```js
// Query at most 5 messaging channels where current user is a member,
// by channel name:
const channels = await client.queryChannels(
  {
    type: 'messaging',
    name: { $autocomplete: query },
    members: { $in: [userId] },
  },
  { last_message_at: -1, updated_at: -1 },
  { limit: 5 },
);
```

```js
// Query at most 5 users (except the current one), by user name or id:
const { users } = await client.queryUsers(
  {
    $or: [{ id: { $autocomplete: query } }, { name: { $autocomplete: query } }],
    id: { $ne: userId },
  },
  { id: 1, name: 1 },
  { limit: 5 },
);
```

```js
// Query at most 5 messages from the messaging channels where current user
// is a member, by message text:
const { results } = await client.search({ type: 'messaging', members: { $in: [userId] } }, query, {
  limit: 5,
});
const messages = results.map((item) => item.message);
```

Next, let's add a simple text input and some buttons to search for channels,
users, or messages:

```jsx
function CustomSearch() {
  const [query, setQuery] = useState('');

  return (
    <div className='search'>
      <input
        type='search'
        className='search-input'
        value={query}
        onChange={(event) => setQuery(event.target.value)}
      />
      {query && (
        <div className='search-actions'>
          <button type='button' className='search-button'>
            #Ô∏è‚É£ Find "{query}" channels
          </button>
          <button type='button' className='search-button'>
            üë§ Find "{query}" users
          </button>
          <button type='button' className='search-button'>
            üí¨ Look up "{query}" in messages
          </button>
        </div>
      )}
    </div>
  );
}
```

So far, our `CustomSearch` component doesn't do anything. Let's wire things up
by adding click event listeners to the search buttons.

One thing we should be mindful about is race conditions: we should either cancel
or discard the results of previous request when making a new one, or prevent a
user from making several requests at the same time. Better yet, use a query
library like [TanStack Query](https://tanstack.com/query/latest) or
[SWR](https://swr.vercel.app/) to make requests.

In this example, we are going to use a helper function that will guard us
against race conditions:

```js
function useSearchQuery() {
  const [results, setResults] = useState(null);
  const [pending, setPending] = useState(false);
  const pendingRequestAbortController = useRef(null);

  const startNextRequestWithSignal = () => {
    pendingRequestAbortController.current?.abort();
    pendingRequestAbortController.current = new AbortController();
    return pendingRequestAbortController.current.signal;
  };

  const querySearchResults = async (fether) => {
    setPending(true);
    const signal = startNextRequestWithSignal();
    const results = await fether();

    if (!signal.aborted) {
      setResults(results);
      setPending(false);
    }
  };

  return { results, pending, querySearchResults };
}
```

:::caution If you're implementing the "search as you type" user experience,
don't forget to debounce or throttle your search requests. Otherwise you can
reach rate limits very quickly. :::

Now we are ready to bring things together by adding the click event handlers to
the search buttons:

```jsx
function CustomSearch() {
  const { client } = useChatContext();
  const [query, setQuery] = useState('');
  const { results, pending, querySearchResults } = useSearchQuery();

  const handleChannelSearchClick = async () => {
    querySearchResults(async () => {
      const channels = await client.queryChannels(
        {
          type: 'messaging',
          name: { $autocomplete: query },
          members: { $in: [userId] },
        },
        { last_message_at: -1, updated_at: -1 },
        { limit: 5 },
      );

      return {
        entity: 'channel',
        items: channels,
      };
    });
  };

  const handleUserSearchClick = async () => {
    querySearchResults(async () => {
      const { users } = await client.queryUsers(
        {
          $or: [{ id: { $autocomplete: query } }, { name: { $autocomplete: query } }],
          id: { $ne: userId },
        },
        { id: 1, name: 1 },
        { limit: 5 },
      );

      return {
        entity: 'user',
        items: users,
      };
    });
  };

  const handleMessageSearchClick = async () => {
    querySearchResults(async () => {
      const { results } = await client.search(
        { type: 'messaging', members: { $in: [userId] } },
        query,
        { limit: 5 },
      );

      return {
        entity: 'message',
        items: results.map((item) => item.message),
      };
    });
  };

  return (
    <div className='search'>
      <input
        type='search'
        className='search-input'
        value={query}
        onChange={(event) => setQuery(event.target.value)}
      />
      {query && (
        <div className='search-actions'>
          <button type='button' className='search-button' onClick={handleChannelSearchClick}>
            #Ô∏è‚É£ Find <strong>"{query}"</strong> channels
          </button>
          <button type='button' className='search-button' onClick={handleUserSearchClick}>
            üë§ Find <strong>"{query}"</strong> users
          </button>
          <button type='button' className='search-button' onClick={handleMessageSearchClick}>
            üí¨ Look up <strong>"{query}"</strong> in messages
          </button>
        </div>
      )}
    </div>
  );
}
```

Finally, we have to display search results to the user. You can use components
like `ChannelPreview` provided by the SDK, or you can roll your own. Let's
create very simple preview components for channels, users, and messages:

```jsx
const ChannelSearchResultPreview = ({ channel }) => (
  <li className='search-results__item'>
    <div className='search-results__icon'>#Ô∏è‚É£</div>
    {channel.data?.name}
  </li>
);

const UserSearchResultPreview = ({ user }) => (
  <li className='search-results__item'>
    <div className='search-results__icon'>üë§</div>
    {user.name ?? user.id}
  </li>
);

const MessageSearchResultPreview = ({ message }) => (
  <li className='search-results__item'>
    <div className='search-results__icon'>üí¨</div>
    {message.text}
  </li>
);

const SearchResultsPreview = ({ results }) => {
  if (results.items.length === 0) {
    return <div class='search-results'>ü§∑‚Äç‚ôÇÔ∏è No results</div>;
  }

  return (
    <ul className='search-results'>
      {results.entity === 'channel' &&
        results.items.map((item) => <ChannelSearchResultPreview key={item.cid} channel={item} />)}
      {results.entity === 'user' &&
        results.items.map((item) => <UserSearchResultPreview key={item.id} user={item} />)}
      {results.entity === 'message' &&
        results.items.map((item) => <MessageSearchResultPreview key={item.id} message={item} />)}
    </ul>
  );
};
```

```css
.search-results {
  list-style: none;
  padding: 0;
  margin: 0;
}

.search-results__item {
  padding-left: 30px;
}

.search-results__item:not(:last-child) {
  margin-bottom: 10px;
  padding-bottom: 10px;
  border-bottom: 1px solid #dbdde1;
}

.search-results__icon {
  display: inline-block;
  width: 30px;
  margin-left: -30px;
}
```

What happens when clicking on a search results depends on your desired user
experience. When clicking on a channel, it makes sense of set the channel as
active. When clicking on a user, you might want to create or open a channel with
a one-on-one coversation with the user. When clicking on a message, it's
probably expected that a relevant channel is set as active and scrolled to the
message in question.

```jsx
import { useChatContext } from 'stream-chat-react';

const ChannelSearchResultPreview = ({ channel }) => {
  const { setActiveChannel } = useChatContext();

  return (
    <li className='search-results__item' onClick={() => setActiveChannel(channel)}>
      <div className='search-results__icon'>#Ô∏è‚É£</div>
      {channel.data?.name}
    </li>
  );
};
```

```jsx
import { useChatContext } from 'stream-chat-react';

const UserSearchResultPreview = ({ user }) => {
  const { client, setActiveChannel } = useChatContext();

  const handleClick = async () => {
    const channel = client.channel('messaging', { members: [userId, user.id] });
    await channel.watch();
    setActiveChannel(channel);
  };

  return (
    <li className='search-results__item' onClick={handleClick}>
      <div className='search-results__icon'>üë§</div>
      {user.name ?? user.id}
    </li>
  );
};
```

```jsx
const MessageSearchResultPreview = ({ message }) => {
  const history = useHistory(); // bring your own router of choice
  const { client, setActiveChannel } = useChatContext();

  const handleClick = async () => {
    if (message.channel) {
      const channel = client.channel(message.channel.type, message.channel.id);
      setActiveChannel(channel);
      await channel.state.loadMessageIntoState(message.id);
      history.replace(`${window.location.pathname}#${message.id}`);
    }
  };

  return (
    <li className='search-results__item' onClick={handleClick}>
      <div className='search-results__icon'>üí¨</div>
      {message.text}
    </li>
  );
};
```

And that's it! Here's the complete code:

```jsx

```
